# Reacting to Input with State
- 宣言型プログラミングとは、UIを細かく管理する（命令型）のではなく、視覚的な状態ごとにUIを記述することを意味する。
- コンポーネントを開発するとき
  1. すべての視覚状態を特定する。
  1. 状態を変更するための人間とコンピューターのトリガーを決定する。
  1. 状態をuseStateでモデル化する。
  1. バグやパラドックスを避けるために、必要でないステートを削除する。
  1. 状態を設定するイベント・ハンドラを接続する。
# Choosing the State Structures
- 2つの状態変数が常に一緒に更新される場合は、それらを1つに統合することを検討する。
- 不可能な状態を作らないように、状態変数は慎重に選びましょう。
- 状態の更新を間違える可能性を減らすように、状態を構造化する。
- 同期させる必要がないように、冗長で重複したステートは避ける。
- 特に更新を防ぎたい場合を除き、propsをステートに入れない。
- 選択などのUIパターンでは、オブジェクトそのものではなく、IDやインデックスをステートに保持する。
- 深くネストされたステートの更新が複雑な場合は、フラット化する。
# Sharing State Between Components
- 2つのコンポーネントを協調させたい場合、それらの状態を共通の親に移動させる。
- 次に、共通の親からpropsを通して情報を下に渡します。
- 最後に、子コンポーネントが親の状態を変更できるように、イベントハンドラを下に渡します。
- コンポーネントを「制御型」（propsによって駆動される）または「非制御型」（ステートによって駆動される）と考えると便利です。
# Preserving and Resetting State
- Reactは、同じコンポーネントが同じ位置にレンダリングされる限り、状態を保持する。
- ステートはJSXタグには保持されない。ステートは、JSXを配置したツリーの位置に関連付けられます。
- サブツリーに別のキーを与えることで、サブツリーの状態を強制的にリセットできます。
- コンポーネント定義を入れ子にしないでください。
# Extracting State Logic into a Reducer
- useStateからuseReducerに変換する：
  1. イベント・ハンドラからアクションをディスパッチする。
  1. 与えられた状態とアクションに対して次の状態を返すreducer関数を記述します。
  1. useStateをuseReducerに置き換えてください。
- リデューサーは少し多くのコードを書く必要がありますが、デバッグやテストに役立ちます。
- Reducerは純粋でなければなりません。
- 各アクションは、単一のユーザーとの対話を記述します。
- mutating スタイルでリデューサーを書きたい場合は Immer を使いましょう。
# Passing Data Deeply with Context
- コンテキストは、コンポーネントがその下のツリー全体に何らかの情報を提供することを可能にします。
- コンテキストを渡すには
  1. `export const MyContext = createContext(defaultValue)` でコンテキストを作成し、エクスポートします。
  1. これを `useContext(MyContext)` Hook に渡すと、どんなに深い子コンポーネントでも読み込むことができます。
  1. 子コンポーネントを`<MyContext.Provider value={...}>`で囲むと、親コンポーネントから読み込むことができます。
- Contextは途中のコンポーネントを通過する。
- コンテキストを使えば、「周囲に適応する」コンポーネントを書くことができる。
- コンテキストを使う前に、子コンポーネントとしてpropsを渡したり、JSXを渡したりしてみてください。